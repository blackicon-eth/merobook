/** @generated by @calimero/abi-codegen â€” DO NOT EDIT. */

import { CalimeroApp, Context } from '@calimero-network/calimero-client';

// Generated types

export interface Like {
  user_id: string;
  user_name: string;
  timestamp: number;
}

export interface Post {
  id: string;
  author_id: string;
  author_name: string;
  author_avatar: string;
  content: string;
  timestamp: number;
  likes: Like[];
}

export interface User {
  id: string;
  name: string;
  avatar: string;
  bio: string;
}

export type AbiEvent =
  | { name: 'UserCreated' }
  | { name: 'PostCreated' }
  | { name: 'PostLiked' }
  | { name: 'PostUnliked' };

/**
 * Utility class for handling byte conversions in Calimero
 */
export class CalimeroBytes {
  private data: Uint8Array;

  constructor(input: string | number[] | Uint8Array) {
    if (typeof input === 'string') {
      // Hex string
      this.data = new Uint8Array(
        input.match(/.{1,2}/g)?.map((byte) => parseInt(byte, 16)) || [],
      );
    } else if (Array.isArray(input)) {
      // Number array
      this.data = new Uint8Array(input);
    } else {
      // Uint8Array
      this.data = input;
    }
  }

  toArray(): number[] {
    return Array.from(this.data);
  }

  toUint8Array(): Uint8Array {
    return this.data;
  }

  static fromHex(hex: string): CalimeroBytes {
    return new CalimeroBytes(hex);
  }

  static fromArray(arr: number[]): CalimeroBytes {
    return new CalimeroBytes(arr);
  }

  static fromUint8Array(bytes: Uint8Array): CalimeroBytes {
    return new CalimeroBytes(bytes);
  }
}

export class AbiClient {
  private app: CalimeroApp;
  private context: Context;

  constructor(app: CalimeroApp, context: Context) {
    this.app = app;
    this.context = context;
  }

  /**
   * init
   */
  public async init(): Promise<void> {
    const response = await this.app.execute(this.context, 'init', {});
    if (response.success) {
      return response.result as void;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * create_user
   */
  public async createUser(params: {
    name: string;
    avatar: string;
    bio: string;
    public_key: string;
  }): Promise<User> {
    const response = await this.app.execute(
      this.context,
      'create_user',
      params,
    );
    if (response.success) {
      return response.result as User;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_user_by_public_key
   */
  public async getUserByPublicKey(params: {
    public_key: string;
  }): Promise<User> {
    const response = await this.app.execute(
      this.context,
      'get_user_by_public_key',
      params,
    );
    if (response.success) {
      return response.result as User;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * check_public_key_registered
   */
  public async checkPublicKeyRegistered(params: {
    public_key: string;
  }): Promise<boolean> {
    const response = await this.app.execute(
      this.context,
      'check_public_key_registered',
      params,
    );
    if (response.success) {
      return response.result as boolean;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_user
   */
  public async getUser(params: { id: string }): Promise<User> {
    const response = await this.app.execute(this.context, 'get_user', params);
    if (response.success) {
      return response.result as User;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_all_users
   */
  public async getAllUsers(): Promise<User[]> {
    const response = await this.app.execute(this.context, 'get_all_users', {});
    if (response.success) {
      return response.result as User[];
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * create_post
   */
  public async createPost(params: {
    author_id: string;
    content: string;
  }): Promise<Post> {
    const response = await this.app.execute(
      this.context,
      'create_post',
      params,
    );
    if (response.success) {
      return response.result as Post;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_all_posts
   */
  public async getAllPosts(): Promise<Post[]> {
    const response = await this.app.execute(this.context, 'get_all_posts', {});
    if (response.success) {
      return response.result as Post[];
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_post
   */
  public async getPost(params: { id: string }): Promise<Post> {
    const response = await this.app.execute(this.context, 'get_post', params);
    if (response.success) {
      return response.result as Post;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * like_post
   */
  public async likePost(params: {
    post_id: string;
    user_id: string;
  }): Promise<Post> {
    const response = await this.app.execute(this.context, 'like_post', params);
    if (response.success) {
      return response.result as Post;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * unlike_post
   */
  public async unlikePost(params: {
    post_id: string;
    user_id: string;
  }): Promise<Post> {
    const response = await this.app.execute(
      this.context,
      'unlike_post',
      params,
    );
    if (response.success) {
      return response.result as Post;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * check_user_liked_post
   */
  public async checkUserLikedPost(params: {
    post_id: string;
    user_id: string;
  }): Promise<boolean> {
    const response = await this.app.execute(
      this.context,
      'check_user_liked_post',
      params,
    );
    if (response.success) {
      return response.result as boolean;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }

  /**
   * get_post_count
   */
  public async getPostCount(): Promise<number> {
    const response = await this.app.execute(this.context, 'get_post_count', {});
    if (response.success) {
      return response.result as number;
    } else {
      throw new Error(response.error || 'Execution failed');
    }
  }
}
